!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE STATE_UPDATE_MOD_DIFF
#include <petsc/finclude/petscsys.h>
  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  USE FLUX_RESIDUAL_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of state_update in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.prim)
!   with respect to varying inputs: *(point.nx) *(point.ny) *(point.prim)
!                *(point.prim_old) *(point.flux_res)
!   Plus diff mem management of: point.nx:in point.ny:in point.prim:in
!                point.prim_old:in point.flux_res:in
  SUBROUTINE STATE_UPDATE_D(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: ud(4), tempd, u_oldd(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: nxd, nyd
    REAL*8 :: u2_rot, u3_rot
    REAL*8 :: u2_rotd, u3_rotd
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    REAL*8 :: temp0
    max_res = 0.0d0
    sum_res_sqr = 0.0d0
    ud = 0.0_8
    u_oldd = 0.0_8
    DO i=1,wall_points
      k = wall_points_index(i)
      nxd = pointd%nx(k)
      nx = point%nx(k)
      nyd = pointd%ny(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, nxd, ny, nyd, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, nxd, ny, nyd, u_old, &
&                             u_oldd)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - euler*0.5d0*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      ud(3) = 0.0_8
      u(3) = 0.d0
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + u2_rot*nyd + nx*u3_rotd + u3_rot*nxd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd + u3_rot*nyd - nx*u2_rotd - u2_rot*nxd
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = temp*ud(2) + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = temp*ud(3) + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      temp0 = u(2)*u(2) + u(3)*u(3)
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(temp0*tempd+temp*(2*u(2)*&
&       ud(2)+2*u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*(temp*temp0)
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nxd = pointd%nx(k)
      nx = point%nx(k)
      nyd = pointd%ny(k)
      ny = point%ny(k)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim(:, k), pointd%prim(:, k), &
&                            u, ud, nx, nxd, ny, nyd)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim_old(:, k), pointd%prim_old&
&                            (:, k), u_old, u_oldd, nx, nxd, ny, nyd)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - euler*0.5d0*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + u2_rot*nyd + nx*u3_rotd + u3_rot*nxd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd + u3_rot*nyd - nx*u2_rotd - u2_rot*nxd
      u(3) = u3_rot*ny - u2_rot*nx
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = temp*ud(2) + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = temp*ud(3) + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      temp0 = u(2)*u(2) + u(3)*u(3)
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(temp0*tempd+temp*(2*u(2)*&
&       ud(2)+2*u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*(temp*temp0)
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nxd = pointd%nx(k)
      nx = point%nx(k)
      nyd = pointd%ny(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, nxd, ny, nyd, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, nxd, ny, nyd, u_old, &
&                             u_oldd)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - euler*0.5d0*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + u2_rot*nyd + nx*u3_rotd + u3_rot*nxd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd + u3_rot*nyd - nx*u2_rotd - u2_rot*nxd
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = temp*ud(2) + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = temp*ud(3) + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      temp0 = u(2)*u(2) + u(3)*u(3)
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(temp0*tempd+temp*(2*u(2)*&
&       ud(2)+2*u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*(temp*temp0)
    END DO
  END SUBROUTINE STATE_UPDATE_D

  SUBROUTINE STATE_UPDATE(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: u2_rot, u3_rot
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    max_res = 0.0d0
    sum_res_sqr = 0.0d0
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u(3) = 0.d0
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL CONSERVED_VECTOR_UBAR(point%prim(:, k), u, nx, ny)
      CALL CONSERVED_VECTOR_UBAR(point%prim_old(:, k), u_old, nx, ny)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
  END SUBROUTINE STATE_UPDATE

!  Differentiation of primitive_to_conserved in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: prim u nx ny
  SUBROUTINE PRIMITIVE_TO_CONSERVED_D(prim, primd, nx, nxd, ny, nyd, u, &
&   ud)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: rhod, primd(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: ud(4), nxd, nyd
    REAL*8 :: temp1, temp2
    REAL*8 :: temp1d, temp2d
    REAL*8 :: temp
    rhod = primd(1)
    rho = prim(1)
    ud(1) = rhod
    u(1) = rho
    temp1d = prim(2)*rhod + rho*primd(2)
    temp1 = rho*prim(2)
    temp2d = prim(3)*rhod + rho*primd(3)
    temp2 = rho*prim(3)
    temp = (temp1*temp1+temp2*temp2)/rho
    ud(4) = 2.5d0*primd(4) + 0.5d0*(2*temp1*temp1d+2*temp2*temp2d-temp*&
&     rhod)/rho
    u(4) = 2.5d0*prim(4) + 0.5d0*temp
    ud(2) = ny*temp1d + temp1*nyd - nx*temp2d - temp2*nxd
    u(2) = temp1*ny - temp2*nx
    ud(3) = nx*temp1d + temp1*nxd + ny*temp2d + temp2*nyd
    u(3) = temp1*nx + temp2*ny
  END SUBROUTINE PRIMITIVE_TO_CONSERVED_D

  SUBROUTINE PRIMITIVE_TO_CONSERVED(prim, nx, ny, u)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: temp1, temp2
    rho = prim(1)
    u(1) = rho
    temp1 = rho*prim(2)
    temp2 = rho*prim(3)
    u(4) = 2.5d0*prim(4) + 0.5d0*(temp1*temp1+temp2*temp2)/rho
    u(2) = temp1*ny - temp2*nx
    u(3) = temp1*nx + temp2*ny
  END SUBROUTINE PRIMITIVE_TO_CONSERVED

  SUBROUTINE CONSERVED_TO_PRIMITIVE(u, prim)
    IMPLICIT NONE
    REAL*8 :: temp, u(4), prim(4)
    prim(1) = u(1)
    temp = 1.0d0/u(1)
    prim(2) = u(2)*temp
    prim(3) = u(3)*temp
    temp = u(4) - 0.5d0*temp*(u(2)*u(2)+u(3)*u(3))
    prim(4) = 0.4d0*temp
  END SUBROUTINE CONSERVED_TO_PRIMITIVE

!  Differentiation of func_delta in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.delta)
!   with respect to varying inputs: *(point.x) *(point.y) *(point.prim)
!                *(point.delta)
!   Plus diff mem management of: point.x:in point.y:in point.prim:in
!                point.delta:in
!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA_D()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: delta_td
    REAL*8 :: min_dist
    REAL*8, SAVE :: lmin=1.0d0
    REAL*8 :: gmin
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: u1d, u2d, rhod, prd, mod_ud
    REAL*8 :: dist
    REAL*8 :: distd
    REAL*8 :: min_delt
    REAL*8 :: min_deltd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: temp
    REAL*8 :: temp0
    PetscErrorCode :: ierr
    DO i=1,local_points
      min_delt = 1.0d0
      min_deltd = 0.0_8
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rhod = pointd%prim(1, k)
        rho = point%prim(1, k)
        u1d = pointd%prim(2, k)
        u1 = point%prim(2, k)
        u2d = pointd%prim(3, k)
        u2 = point%prim(3, k)
        prd = pointd%prim(4, k)
        pr = point%prim(4, k)
        x_id = pointd%x(i)
        x_i = point%x(i)
        y_id = pointd%y(i)
        y_i = point%y(i)
        x_kd = pointd%x(k)
        x_k = point%x(k)
        y_kd = pointd%y(k)
        y_k = point%y(k)
        distd = 2*(x_k-x_i)*(x_kd-x_id) + 2*(y_k-y_i)*(y_kd-y_id)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        temp = DSQRT(dist)
        IF (dist .EQ. 0.0) THEN
          distd = 0.0_8
        ELSE
          distd = distd/(2.D0*DSQRT(dist))
        END IF
        dist = temp
        arg1d = 2*u1*u1d + 2*u2*u2d
        arg1 = u1*u1 + u2*u2
        temp = DSQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          mod_ud = 0.0_8
        ELSE
          mod_ud = arg1d/(2.D0*DSQRT(arg1))
        END IF
        mod_u = temp
        arg1d = (prd-pr*rhod/rho)/rho
        arg1 = pr/rho
        temp = DSQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.D0
        ELSE
          result1d = arg1d/(2.D0*DSQRT(arg1))
        END IF
        result1 = temp
        temp0 = dist/(mod_u+3.0d0*result1)
        delta_td = (distd-temp0*(mod_ud+3.0d0*result1d))/(mod_u+3.0d0*&
&         result1)
        delta_t = temp0
        delta_td = cfl*delta_td
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) THEN
          min_deltd = delta_td
          min_delt = delta_t
        END IF
      END DO
      pointd%delta(i) = min_deltd
      point%delta(i) = min_delt
    END DO
  END SUBROUTINE FUNC_DELTA_D

!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: min_dist
    REAL*8, SAVE :: lmin=1.0d0
    REAL*8 :: gmin
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: dist
    REAL*8 :: min_delt
    INTRINSIC DSQRT
    REAL*8 :: arg1
    DOUBLE PRECISION :: result1
    PetscErrorCode :: ierr
    DO i=1,local_points
      min_delt = 1.0d0
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rho = point%prim(1, k)
        u1 = point%prim(2, k)
        u2 = point%prim(3, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        dist = DSQRT(dist)
        arg1 = u1*u1 + u2*u2
        mod_u = DSQRT(arg1)
        arg1 = pr/rho
        result1 = DSQRT(arg1)
        delta_t = dist/(mod_u+3.0d0*result1)
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) min_delt = delta_t
      END DO
      point%delta(i) = min_delt
    END DO
  END SUBROUTINE FUNC_DELTA

!  Differentiation of conserved_vector_ubar in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: ubar
!   with respect to varying inputs: q_inf prim nx ny ubar
  SUBROUTINE CONSERVED_VECTOR_UBAR_D(prim, primd, ubar, ubard, nx, nxd, &
&   ny, nyd)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1_inf_rotd, u2_inf_rotd, e_infd
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: u1d, u2d, prd, rhod, u1_rotd, u2_rotd, ed
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: betad, s2d, b2_infd, a2n_infd
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: b2d, a2pd, temp1d, temp2d
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: ubard(4), primd(4)
    REAL*8 :: nx, ny, tx, ty
    REAL*8 :: nxd, nyd, txd, tyd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    REAL*8 :: result10
    REAL*8 :: result10d
    REAL*8 :: temp
    u1_inf = q_inf(2)
    u2_inf = q_inf(3)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    u1_inf_rotd = u1_inf*txd + u2_inf*tyd
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rotd = u1_inf*nxd + u2_inf*nyd
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1d = 2*u1_inf_rot*u1_inf_rotd + 2*u2_inf_rot*u2_inf_rotd
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_infd = 0.5d0*temp1d
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    result1 = DSQRT(beta)
    s2d = result1*u2_inf_rotd
    s2 = u2_inf_rot*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2_infd = -(DEXP(-(s2**2))*2*s2*s2d/(2.0d0*result1))
    b2_inf = DEXP(-(s2*s2))/(2.0d0*result1)
    result1d = dexp(-s2**2)*(2.d0/sqrt(pi))*s2d
    result1 = derf(s2)
    a2n_infd = -(0.5d0*result1d)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rhod = primd(1)
    rho = prim(1)
    u1d = primd(2)
    u1 = prim(2)
    u2d = primd(3)
    u2 = prim(3)
    prd = primd(4)
    pr = prim(4)
    u1_rotd = tx*u1d + u1*txd + ty*u2d + u2*tyd
    u1_rot = u1*tx + u2*ty
    u2_rotd = nx*u1d + u1*nxd + ny*u2d + u2*nyd
    u2_rot = u1*nx + u2*ny
    temp1d = 2*u1_rot*u1_rotd + 2*u2_rot*u2_rotd
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    temp = pr/((gamma-1.0d0)*rho)
    ed = (prd-temp*(gamma-1.0d0)*rhod)/((gamma-1.0d0)*rho) + 0.5d0*&
&     temp1d
    e = temp + 0.5d0*temp1
    temp = rho/(2.0d0*pr)
    betad = (rhod-temp*2.0d0*prd)/(2.0d0*pr)
    beta = temp
    temp = SQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result10d = 0.0_8
    ELSE
      result10d = betad/(2.0*temp)
    END IF
    result10 = temp
    s2d = result10*u2_rotd + u2_rot*result10d
    s2 = u2_rot*result10
    arg1d = pi*betad
    arg1 = pi*beta
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.0_8
    ELSE
      result10d = arg1d/(2.0*temp)
    END IF
    result10 = temp
    temp = EXP(-(s2*s2))/(2.0d0*result10)
    b2d = (-(EXP(-(s2**2))*2*s2*s2d)-temp*2.0d0*result10d)/(2.0d0*&
&     result10)
    b2 = temp
    result1d = dexp(-s2**2)*(2.d0/sqrt(pi))*s2d
    result1 = derf(s2)
    a2pd = 0.5d0*result1d
    a2p = 0.5d0*(1.0d0+result1)
    ubard(1) = rho_inf*a2n_infd + a2p*rhod + rho*a2pd
    ubar(1) = rho_inf*a2n_inf + rho*a2p
    ubard(2) = rho_inf*(a2n_inf*u1_inf_rotd+u1_inf_rot*a2n_infd) + a2p*(&
&     u1_rot*rhod+rho*u1_rotd) + rho*u1_rot*a2pd
    ubar(2) = rho_inf*u1_inf_rot*a2n_inf + rho*u1_rot*a2p
    temp1d = rho_inf*(a2n_inf*u2_inf_rotd+u2_inf_rot*a2n_infd-b2_infd)
    temp1 = rho_inf*(u2_inf_rot*a2n_inf-b2_inf)
    temp2d = (u2_rot*a2p+b2)*rhod + rho*(a2p*u2_rotd+u2_rot*a2pd+b2d)
    temp2 = rho*(u2_rot*a2p+b2)
    ubard(3) = temp1d + temp2d
    ubar(3) = temp1 + temp2
    temp1d = rho_inf*(e_inf*a2n_infd+a2n_inf*e_infd) - rho_inf*0.5d0*(&
&     b2_inf*u2_inf_rotd+u2_inf_rot*b2_infd)
    temp1 = rho_inf*a2n_inf*e_inf - 0.5d0*rho_inf*u2_inf_rot*b2_inf
    temp2d = e*(a2p*rhod+rho*a2pd) + rho*a2p*ed + 0.5d0*(b2*(u2_rot*rhod&
&     +rho*u2_rotd)+rho*u2_rot*b2d)
    temp2 = rho*a2p*e + 0.5d0*rho*u2_rot*b2
    ubard(4) = temp1d + temp2d
    ubar(4) = temp1 + temp2
  END SUBROUTINE CONSERVED_VECTOR_UBAR_D

  SUBROUTINE CONSERVED_VECTOR_UBAR(prim, ubar, nx, ny)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: nx, ny, tx, ty
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    REAL*8 :: result10
    u1_inf = q_inf(2)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    result1 = DSQRT(beta)
    s2 = u2_inf_rot*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*result1)
    result1 = DERF(s2)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rho = prim(1)
    u1 = prim(2)
    u2 = prim(3)
    pr = prim(4)
    u1_rot = u1*tx + u2*ty
    u2_rot = u1*nx + u2*ny
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    beta = rho/(2.0d0*pr)
    result10 = SQRT(beta)
    s2 = u2_rot*result10
    arg1 = pi*beta
    result10 = SQRT(arg1)
    b2 = EXP(-(s2*s2))/(2.0d0*result10)
    result1 = DERF(s2)
    a2p = 0.5d0*(1.0d0+result1)
    ubar(1) = rho_inf*a2n_inf + rho*a2p
    ubar(2) = rho_inf*u1_inf_rot*a2n_inf + rho*u1_rot*a2p
    temp1 = rho_inf*(u2_inf_rot*a2n_inf-b2_inf)
    temp2 = rho*(u2_rot*a2p+b2)
    ubar(3) = temp1 + temp2
    temp1 = rho_inf*a2n_inf*e_inf - 0.5d0*rho_inf*u2_inf_rot*b2_inf
    temp2 = rho*a2p*e + 0.5d0*rho*u2_rot*b2
    ubar(4) = temp1 + temp2
  END SUBROUTINE CONSERVED_VECTOR_UBAR

END MODULE STATE_UPDATE_MOD_DIFF

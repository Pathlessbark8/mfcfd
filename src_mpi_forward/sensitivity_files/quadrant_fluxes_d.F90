!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE QUADRANT_FLUXES_MOD_DIFF
!	This module consists of quadrant split fluxes 
!	with respect to the x-coordinate direction ..
  USE PARAMETER_MOD
  IMPLICIT NONE
!

CONTAINS
!  Differentiation of flux_quad_gxi in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXI_D(g, gd, nx, nxd, ny, nyd, u1, u1d, u2, u2d, &
&   rho, rhod, pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txd, tyd, nxd, nyd, utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: a1negd, a2negd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd

    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    utd = tx*u1d + u1*txd + ty*u2d + u2*tyd
    ut = u1*tx + u2*ty
    und = nx*u1d + u1*nxd + ny*u2d + u2*nyd
    un = u1*nx + u2*ny
    betad = 0.5d0*(rhod-rho*prd/pr)/pr
    beta = 0.5d0*rho/pr
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s1d = result1*utd + ut*result1d
    s1 = ut*result1
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s2d = result1*und + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s1*s1))/result1
    b1d = 0.5d0*(-(DEXP(-(s1**2))*2*s1*s1d)-temp*result1d)/result1
    b1 = 0.5d0*temp
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s2*s2))/result1
    b2d = 0.5d0*(-(DEXP(-(s2**2))*2*s2*s2d)-temp*result1d)/result1
    b2 = 0.5d0*temp
    result1d = dexp(-s1**2)*(2.d0/sqrt(pi))*s1d
    result1 = derf(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
    ! result1d = DERF_D(s2, s2d, result1)
    result1d = dexp(-s2**2)*(2.d0/sqrt(pi))*s2d
    result1 = derf(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rhod = (prd-pr*rhod/rho)/rho
    pr_by_rho = pr/rho
    u_sqrd = 2*ut*utd + 2*un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (ut*a1neg-b1)*(a2neg*rhod+rho*a2negd) + rho*a2neg*(a1neg*utd&
&     +ut*a1negd-b1d)
    g(1) = rho*a2neg*(ut*a1neg-b1)
    temp1d = pr_by_rhod + 2*ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = a1neg*temp1d + temp1*a1negd - b1*utd - ut*b1d
    temp2 = temp1*a1neg - ut*b1
    gd(2) = temp2*(a2neg*rhod+rho*a2negd) + rho*a2neg*temp2d
    g(2) = rho*a2neg*temp2
    temp1d = a1neg*utd + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp2d = a2neg*und + un*a2negd - b2d
    temp2 = un*a2neg - b2
    gd(3) = temp2*(temp1*rhod+rho*temp1d) + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*(a1neg*(temp1*utd+ut*temp1d)+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(temp1*b1d+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = a1neg*utd + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp4d = 0.5d0*(b2*temp1*(un*rhod+rho*und)+rho*un*(temp1*b2d+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (temp2-temp3)*(a2neg*rhod+rho*a2negd) + rho*a2neg*(temp2d-&
&     temp3d) - temp4d
    g(4) = rho*a2neg*(temp2-temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXI_D

  SUBROUTINE FLUX_QUAD_GXI(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr

    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2neg*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2-temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXI

!  Differentiation of flux_quad_gxii in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXII_D(g, gd, nx, nxd, ny, nyd, u1, u1d, u2, u2d&
&   , rho, rhod, pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txd, tyd, nxd, nyd, utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: a1posd, a2negd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd

    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    utd = tx*u1d + u1*txd + ty*u2d + u2*tyd
    ut = u1*tx + u2*ty
    und = nx*u1d + u1*nxd + ny*u2d + u2*nyd
    un = u1*nx + u2*ny
    betad = 0.5d0*(rhod-rho*prd/pr)/pr
    beta = 0.5d0*rho/pr
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s1d = result1*utd + ut*result1d
    s1 = ut*result1
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s2d = result1*und + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s1*s1))/result1
    b1d = 0.5d0*(-(DEXP(-(s1**2))*2*s1*s1d)-temp*result1d)/result1
    b1 = 0.5d0*temp
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s2*s2))/result1
    b2d = 0.5d0*(-(DEXP(-(s2**2))*2*s2*s2d)-temp*result1d)/result1
    b2 = 0.5d0*temp
    result1d = dexp(-s1**2)*(2.d0/sqrt(pi))*s1d
    result1 = derf(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.d0+result1)
    ! result1d = DERF_D(s2, s2d, result1)
    result1d = dexp(-s2**2)*(2.d0/sqrt(pi))*s2d
    result1 = derf(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rhod = (prd-pr*rhod/rho)/rho
    pr_by_rho = pr/rho
    u_sqrd = 2*ut*utd + 2*un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (ut*a1pos+b1)*(a2neg*rhod+rho*a2negd) + rho*a2neg*(a1pos*utd&
&     +ut*a1posd+b1d)
    g(1) = rho*a2neg*(ut*a1pos+b1)
    temp1d = pr_by_rhod + 2*ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = a1pos*temp1d + temp1*a1posd + b1*utd + ut*b1d
    temp2 = temp1*a1pos + ut*b1
    gd(2) = temp2*(a2neg*rhod+rho*a2negd) + rho*a2neg*temp2d
    g(2) = rho*a2neg*temp2
    temp1d = a1pos*utd + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp2d = a2neg*und + un*a2negd - b2d
    temp2 = un*a2neg - b2
    gd(3) = temp2*(temp1*rhod+rho*temp1d) + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*(a1pos*(temp1*utd+ut*temp1d)+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(temp1*b1d+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = a1pos*utd + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp4d = 0.5d0*(b2*temp1*(un*rhod+rho*und)+rho*un*(temp1*b2d+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (temp2+temp3)*(a2neg*rhod+rho*a2negd) + rho*a2neg*(temp2d+&
&     temp3d) - temp4d
    g(4) = rho*a2neg*(temp2+temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXII_D

  SUBROUTINE FLUX_QUAD_GXII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.d0+result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2neg*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2+temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXII

!  Differentiation of flux_quad_gxiii in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIII_D(g, gd, nx, nxd, ny, nyd, u1, u1d, u2, u2d&
&   , rho, rhod, pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txd, tyd, nxd, nyd, utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: a1posd, a2posd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd

    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    utd = tx*u1d + u1*txd + ty*u2d + u2*tyd
    ut = u1*tx + u2*ty
    und = nx*u1d + u1*nxd + ny*u2d + u2*nyd
    un = u1*nx + u2*ny
    betad = 0.5d0*(rhod-rho*prd/pr)/pr
    beta = 0.5d0*rho/pr
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s1d = result1*utd + ut*result1d
    s1 = ut*result1
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s2d = result1*und + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s1*s1))/result1
    b1d = 0.5d0*(-(DEXP(-(s1**2))*2*s1*s1d)-temp*result1d)/result1
    b1 = 0.5d0*temp
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s2*s2))/result1
    b2d = 0.5d0*(-(DEXP(-(s2**2))*2*s2*s2d)-temp*result1d)/result1
    b2 = 0.5d0*temp
    result1d = dexp(-s1**2)*(2.d0/sqrt(pi))*s1d
    result1 = derf(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.0d0+result1)
    ! result1d = DERF_D(s2, s2d, result1)
    result1d = dexp(-s2**2)*(2.d0/sqrt(pi))*s2d
    result1 = derf(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd-pr*rhod/rho)/rho
    pr_by_rho = pr/rho
    u_sqrd = 2*ut*utd + 2*un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (ut*a1pos+b1)*(a2pos*rhod+rho*a2posd) + rho*a2pos*(a1pos*utd&
&     +ut*a1posd+b1d)
    g(1) = rho*a2pos*(ut*a1pos+b1)
    temp1d = pr_by_rhod + 2*ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = a1pos*temp1d + temp1*a1posd + b1*utd + ut*b1d
    temp2 = temp1*a1pos + ut*b1
    gd(2) = temp2*(a2pos*rhod+rho*a2posd) + rho*a2pos*temp2d
    g(2) = rho*a2pos*temp2
    temp1d = a1pos*utd + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp2d = a2pos*und + un*a2posd + b2d
    temp2 = un*a2pos + b2
    gd(3) = temp2*(temp1*rhod+rho*temp1d) + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*(a1pos*(temp1*utd+ut*temp1d)+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(temp1*b1d+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = a1pos*utd + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp4d = 0.5d0*(b2*temp1*(un*rhod+rho*und)+rho*un*(temp1*b2d+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (temp2+temp3)*(a2pos*rhod+rho*a2posd) + rho*a2pos*(temp2d+&
&     temp3d) + temp4d
    g(4) = rho*a2pos*(temp2+temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIII_D

  SUBROUTINE FLUX_QUAD_GXIII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr

    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2pos*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2+temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIII

!  Differentiation of flux_quad_gxiv in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIV_D(g, gd, nx, nxd, ny, nyd, u1, u1d, u2, u2d&
&   , rho, rhod, pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txd, tyd, nxd, nyd, utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: a1negd, a2posd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd

    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    utd = tx*u1d + u1*txd + ty*u2d + u2*tyd
    ut = u1*tx + u2*ty
    und = nx*u1d + u1*nxd + ny*u2d + u2*nyd
    un = u1*nx + u2*ny
    betad = 0.5d0*(rhod-rho*prd/pr)/pr
    beta = 0.5d0*rho/pr
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s1d = result1*utd + ut*result1d
    s1 = ut*result1
    temp = DSQRT(beta)
    IF (beta .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = betad/(2.D0*DSQRT(beta))
    END IF
    result1 = temp
    s2d = result1*und + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s1*s1))/result1
    b1d = 0.5d0*(-(DEXP(-(s1**2))*2*s1*s1d)-temp*result1d)/result1
    b1 = 0.5d0*temp
    arg1d = pi*betad
    arg1 = pi*beta
    temp = DSQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.D0
    ELSE
      result1d = arg1d/(2.D0*DSQRT(arg1))
    END IF
    result1 = temp
    temp = DEXP(-(s2*s2))/result1
    b2d = 0.5d0*(-(DEXP(-(s2**2))*2*s2*s2d)-temp*result1d)/result1
    b2 = 0.5d0*temp
    result1d = dexp(-s1**2)*(2.d0/sqrt(pi))*s1d
    result1 = derf(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
    ! result1d = DERF_D(s2, s2d, result1)
    result1d = dexp(-s2**2)*(2.d0/sqrt(pi))*s2d
    result1 = derf(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd-pr*rhod/rho)/rho
    pr_by_rho = pr/rho
    u_sqrd = 2*ut*utd + 2*un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (ut*a1neg-b1)*(a2pos*rhod+rho*a2posd) + rho*a2pos*(a1neg*utd&
&     +ut*a1negd-b1d)
    g(1) = rho*a2pos*(ut*a1neg-b1)
    temp1d = pr_by_rhod + 2*ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = a1neg*temp1d + temp1*a1negd - b1*utd - ut*b1d
    temp2 = temp1*a1neg - ut*b1
    gd(2) = temp2*(a2pos*rhod+rho*a2posd) + rho*a2pos*temp2d
    g(2) = rho*a2pos*temp2
    temp1d = a1neg*utd + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp2d = a2pos*und + un*a2posd + b2d
    temp2 = un*a2pos + b2
    gd(3) = temp2*(temp1*rhod+rho*temp1d) + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*(a1neg*(temp1*utd+ut*temp1d)+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(temp1*b1d+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = a1neg*utd + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp4d = 0.5d0*(b2*temp1*(un*rhod+rho*und)+rho*un*(temp1*b2d+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (temp2-temp3)*(a2pos*rhod+rho*a2posd) + rho*a2pos*(temp2d-&
&     temp3d) + temp4d
    g(4) = rho*a2pos*(temp2-temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIV_D

  SUBROUTINE FLUX_QUAD_GXIV(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr

    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2pos*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2-temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIV

END MODULE QUADRANT_FLUXES_MOD_DIFF
